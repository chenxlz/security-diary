![image](assets/v2-2bb831c8a9b71d8d258b36fe5150e05d_r-20240519102525-ytojnds.png)

# 总结缺陷

1. 过于局限了，面试问的问题虽然业务场景是重合的，但是需要回答通用的方案，想路由跳转、权限控制，这个不能按照公司的实际情况来，每个公司情况都是不一样的，有的公司把所有操作都已经封装好了，可能不能把在公司的实际操作那出去说，完全没法体现对技术的理解。
2. **眼神太飘**，不敢看手机屏幕，完全是在看其他地方
3. 有些地方**描述过细致**，说个大概流程即可
4. 英文说不大清楚

# 人事相关

## 自我介绍

1. 面试官你好，我叫xxx，我是xx届本科毕业，目前从事前端开发有 xx 年时间了，目前从事工作岗位是负责公司内部项目的前端开发，主要工作内容是对接产品、用户以及测试对公司现有的产品进行更新迭代，同时维护项目使用文档，目前负责公司 ToB端 的前端项目
2. 最近做的项目是公司的 xxxx 和 xxx 项目 。
3. 工作方向是 pc 网页开发，常用的技术栈是vue及其相关插件，如vue-router路由管理工具，vuex、pinia状态管理工具。有elmment等前端常用组件库的使用经历。
4. 目前在学习node.js\react中，未来规划是打算从纯网页前端方向转向服务器端、跨平台应用上。

## 离开原因

项目组人事变动较大，不够稳定，同时感觉自身被目前环境限制，换个新环境提升自我。

## 对我们有什么需要了解的

1. 面试官如何称呼
2. 公司项目组的业务方向
3. 所使用的技术栈，是vue2还是vue3
4. 目前项目的人员组成

# 项目相关

## 介绍下最熟悉的项目

## 项目的难点

1. 页面缓存后更新问题

    1. keepalive  组件缓存组件，减少重复渲染的性能
    2. 同时又有更新数据更新的需求，使用activbed 生命周期，对需要更新的数据进行更新
2. dom的删除问题

    1. mutationObserve ,本地环境调试不行
3. 组件嵌套太深传值的问题

    1. 使用inject 依赖阶级
4. 使用h函数生成实际dom对页面进行添加
5. 组件的嵌套封装多层，使用v-model，利用 计算属性进行封装
6. 共同参数问题

    1. 使用类的static 关键字，使用基类的静态成员变量，来实现公共参数的同意配置
7. excel解析文件，通过数据再一个个去调用接口，使用xlsx.js该文件，获取文件的数据，再循环遍历。
8. 中断请求

    1. 两个下拉框是有选择项目需要使用前一个选项的数据，
    2. 使用cancelToken去中断请求，或者说是浏览器端需求后续的返回数据处理
    3. ‍
9. 数据的响应式

    1. 大数据情况，响应式是消耗系统性能的
    2. 使用 Object.freeze()  来冻结对象，
10. 页面位置的跳转

     1. dom.scrollIntoView()

## vue开发中的坑点，如何解决

1. 直接对对象、或者数组进行数据的删除或变更，不能触发响应式

    1. 触发的是get、set，新增属性没有添加依赖关系，直接删除不能触发getter、setter
2. 代理配置域名问题和ip的映射关系

    1. 设置 localhost.xxx.com  需要 host文件修改 ip映射关系 127.0.0.1
3. updated获取dom不成功

    1. 数据虽然更新，但是dom未必已经更新了 使用nextTick
4. setTimeout中的异步回调函数this未指向实例

    1. 使用箭头函数
5. created和mouted生命周期中获取dom
6. 在父组件中传递的 props 改变时，子组件中的数据可能不会立即更新。

    1. 使用 `watch`​ 监听 props 的变化。
7. keep-alive组件缓存

    1. 使用actived、deactived来处理切换逻辑
8. 在同一个路由下，动态参数变化不会触发组件的重新加载。

    1. 使用 `watch`​ 监听 `$route`​ 对象的变化。
9. 在复杂表单中，双向绑定（v-model）可能无法满足所有需求，特别是在处理自定义输入组件时。

    1. 对于复杂输入组件，显式地使用 `:value`​ 和 `@input`​ 事件进行绑定和更新。
10. 默认插槽内容的更新不会触发父组件的更新。

     1. 确保插槽内容通过响应式数据传递，或使用 `$forceUpdate`​ 强制父组件重新渲染。
11. 在路由导航守卫中进行异步操作时，未正确处理异步逻辑会导致导航失败或意外行为

     1. 确保在导航守卫中使用 `next`​ 方法正确处理异步逻辑

## 技术选型

## token过期，请求并发如何处理

方案一：

核心是设置一个变量用来判断token是否过期，创建一个数组队列用来收集此时的请求

默认该变量就是false状态

请求发起时，判断变量，为false时，同时队列不为空，则任务推送到队列中，进行等待，等待第一个返回结果，再统一处理，是跳转登入页面，还是重新发起请求

如果队列此时为空，说明这个请求是第一个请求，所以先把该任务推送到队列中，用于后续请求的队列判断，后面发送第一个请求，如果可以拿到新token则队列中的任务重新发起，不能的话就跳转到登陆页面，队列中的任务直接清空

‍

方案二：方案一中的方法，需要去判断第一个请求的返回结果再去处理后续请求，如果第一个请求的结果返回时间比较长，会导致请求堵塞。

同样使用变量去判断token是否过期，默认设置已过期

在token过期发起请求的情况下，这个时候发起的任务收集到队列数组中，同时请求携带`abortController`​，最快的请求返回之后，判断条件，token过去的情况下，把队列中其他请求全部取消，同时进行页面跳转

‍

## 项目的优化

1. 图片预加载，css放入到head中，js放到body后或者加入async属性
2. 减少http请求，图片静态资源cdn托管，小图标使用精灵图
3. 资源多域放置
4. 图片懒加载，外部资源按需加载
5. 压缩js、css
6. 使用gzip

## 工程化中es6如何转化成es5

在工程化中，将ES6转换为ES5通常涉及使用构建工具或转译器。

[Babel](https://babeljs.io/)是一个流行的JavaScript转译器，可将新版本的JavaScript代码转换为向后兼容的ES5代码。

```ts
module: {
  rules: [
    // 对js文件进行babel-loader处理（将ES6语法转换成ES5）
      {
        test: /.js$/,
        exclude: /node_modules/,
        loader: "babel-loader"
      }
  ]
}
```

bebal转es5主要涉及到的步骤

1. **解析（Parsing）** ：Babel首先会将输入的代码字符串解析成抽象语法树（Abstract Syntax Tree, AST），这是一个树状结构，表示代码的语法结构。
2. **转换（Transformation）** ：在得到AST之后，Babel会对AST进行遍历和修改，根据预设的转换规则（plugins和presets）来进行相应的转换。这些转换规则包括将ES6+语法转换为ES5语法，如箭头函数、模板字符串、类、模块化等。
3. **生成（Generation）** ：转换完成后，Babel会将修改后的AST重新转换为代码字符串，生成最终的ES5代码。

# vue相关

## vue是如何实现发布订阅者模式的

这个比较概念，没说到vue的核心

1. **观察者（Observer）** ：观察者负责监视数据的变化。在Vue中，Vue实例会通过`Object.defineProperty`​或ES6 Proxy来劫持数据的属性，从而实现数据的响应式监测。
2. **订阅者（Subscriber）** ：订阅者订阅了观察者，并在观察者状态发生变化时接收通知。在Vue中，视图（组件）是订阅者，它们会订阅数据的变化，并在数据变化时自动更新视图。
3. **依赖追踪（Dependency Tracking）** ：Vue会在模板编译过程中分析模板中的数据依赖关系，并将其转换为依赖关系图。当数据发生变化时，Vue会根据依赖关系图自动更新受影响的视图。
4. **派发更新（Dispatching Updates）** ：当数据发生变化时，Vue会派发更新，通知订阅了该数据的视图进行更新。
5. ‍

数据初始化的时候会对数据进行一个数据劫持，中间对数据的读取、基本操作进行一个拦截

在数据在被使用到时，会把该副作用函数进行一个收集，所有收集到的副作用函数会被放置到一个容器中，并挂载到该响应式数据下 weakMap - obj - map-key -effect

‍

计算属性、侦听器、templat模板就是数据的订阅者，计算属性、侦听器获取响应式数据依赖时，其回调函数会被响应式数据收集，template被转换成render渲染函数，会被被响应式数据收集到依赖

在数据发生变化时，具体数据的变化会触发其对应的副作用函数，、

渲染函数的调用会推送到一个执行队列中，vue会在合适的时间统一执行里面的render函数

‍

‍

## vue指令

1. v-model
2. v-for
3. v-if
4. v-show
5. v-bind
6. v-on
7. v-once
8. v-pre
9. v-cloak
10. v-slot
11. v-text
12. v-html
13. v-memo 自定义条件渲染

## vue数据未响应式

1. this.$set
2. this.$forceUpdata()

# 面试问题

## excel不用插件如何获取数据

原生实现很是复杂

​`.xlsx`​文件需要解压缩读取（因为.xlsx文件实际上是一个包含多个文件的压缩包，通常使用zip格式），读取出多个`.xml`​格式的文件，这些XML文件存储了工作簿、工作表、样式等信息。

解析XML：将这些XML文件解析为JavaScript对象，提取出有用的信息

构建数据结构：将解析出的信息组织成易于使用的数据结构，如JavaScript对象或数组

转换为JSON：将工作表中的数据转换为JSON格式，使其可以在JavaScript应用中方便地使

处理样式和公式：如果需要，还可以解析和应用单元格的样式和公式。

## promise的封装

## canvas画布清晰度

清晰度降低通常是由于Canvas的尺寸和**分辨率**没有同步调整造成的

放大Canvas画布时保持清晰度，可以采取以下步骤

1. **确保Canvas的实际尺寸（分辨率）与CSS尺寸匹配**：

    * 设定Canvas的宽度和高度为其在屏幕上显示尺寸的乘以设备像素比（DPR）。
    * 使用CSS设置Canvas的显示尺寸。
2. **使用Canvas的缩放功能**：

    * 在Canvas上下文中使用`scale`​方法根据DPR进行缩放。

父容器的实际**宽高*dpr**比例（`window.devicePixelRatio`​），然后使用`ctx.scale(dpr, dpr)`​缩放到正确的尺寸

‍

## npm发包

1. 创建并初始化项目
2. 编写代码
3. 测试功能
4. 配置`package.json`​文件

    ```ts
    1.设置打包文件的输出路径
    2.设置好需要发包的内容
    3.写好readme使用文档
    4.设置发包的上传地址
    5.设置发包的密钥或则直接登入
    ```
5. ​​登录npm
6. 发包：`npm pulish`​

## 节流、防抖

## 闭包

## 状态码

```js
1xx :服务器接收到请求了，需要客服端继续发起请求
2xx:请求成功
3xx:重定向
	301资源或网页等被永久转移到其他的URL
    304缓存
4xx:客户端有问题
	400错误的请求，看看是不是请求方法或参数有问题
	401无权限
    402需收费 //是一个非正式的错误编号 没有正式把402加入标准之中？因为402错误没有太大的实用意义
    403服务器拒绝，是不是后台接口权限未配置
    404未找到资源
    405方法不被允许
5xx:服务端有问题
```

## 类选择器

## 瀑布流布局

1. flex方案

    1. 我们对父容器设置弹性盒后，因为瀑布流是多行的所以还要flex-wrap设置wrap，并且flex-direction还要设置为column。最关键的是一定要设置一个高度。当然在其子元素用百分比设定要显示几列。
    2. 实现相对简单。
    3. 图片自动填充不用考虑图片加载状态。
    4. 顺序在一定程度上可以改变。
    5. 高度是固定的，很难做活。
    6. 顺序虽然可以改变，但是仍然不灵活，不尽人意。
2. columns

    1. 天生支持，只需要给父级设置即可 `columns: 4; column-gap: 6px;`​ 。
3. js+absolute方案

    1. js实现瀑布流的话，我们可以考虑把子元素全部设置成绝对定位。然后监听图片加载，如果加载完就把子元素设置其对应的位置，逐个塞到父容器中。
4. ‍

## 设计模式

* 工厂模式
* 单例模式
* 装饰器模式
* 代理模式
* 观察者模式
* 迭代器模式
* 状态模式
* 适配器模式
* 外观模式

## MVC、MVP、MVVM

* MVC

  * 传统的MVC是指，用户操作会请求服务端路由，路由会调用对应的控制器来处理，控制器会获取数据，再将结果返回给前端，前端手动进行页面重新进行渲染，通信是单向的
  * M（Model模型【后端数据库】），V（view视图），C（controller控制器）
  * 主要是基于分层目的，让彼此的职责分开
  * View通过controller来联系Model，controller是View和Model的协调者，View和Model不直接联系，所以基本上通信都是单向的
* MVP

  * M（Model模型），V（view视图），P（Presenter主持？）
  * MVP是从MVC模式演变过来的，都是通过controller / presenter负责逻辑的处理 + Model提供数据 + View负责显示
  * 在MVP中，Presenter完全把Model与View进行了分离，主要的程序逻辑在presenter中实现，并且presenter与view是没有直接关联的，是通过定义好的接口进行交互，从而使得view变更的时候可以保持presenter不变
  * MVP模式的框架

    * Riot.js
* MVVM

  * 传统的前端会将数据手动渲染到页面上，MVVM模式下不需要用户手动操作DOM元素，而是将数据绑定到ViewModel层上，会自动将数据渲染到页面中，视图变化会通知ViewModel层更新数据，ViewModel就是MVVM模式的桥梁
  * M（Model模型），V（view视图），VM（ViewModel）
  * MVVM是双向的
  * MVVM是把MVC里的Controller和MVP里的Presenter改成了ViewModel。Model+View+ViewModel
  * View的变化会自动更新到ViewModel,ViewModel的变化也会自动同步到View上显示
  * 这种自动同步是因为ViewModel中的属性实现了Observer，当属性变更时都能触发对应的操作。
  * MVVM模式的框架

    * AngularJS
    * Vue
    * React

# 移动端相关

## 移动端边框0.5px

* 伪类缩放： 【 :after 1px 然后 transform:scale(0.5)】

## 小程序的生命周期

1. 应用级

    1. onLuch应用加载
    2. onShow 应用显示
    3. onHide应用后台
    4. onError应用出错
    5. onPageNotFound页面找不到
2. 页面级

    1. onLoad页面加载 一次
    2. onRead页面加载完成 一次
    3. onShow 页面显示
    4. onHide 页面隐藏
    5. onUnload 页面卸载
    6. onPullDownRefrch 页面下拉
    7. onReachBottom页面上拉
    8. onShareAppMessage页面分享
    9. onPageScroll页面滚动
    10. onResize页面大小变化
3. 组件级

    1. created 组件创建
    2. attached 组件移入节点树
    3. ready 组件渲染完成
    4. moved 组件移除节点树
    5. detached 组件卸载

## 小程序的路由导航

1. wx.navigateTo 保留当前页，进行page跳转
2. wx.redirectTo 关闭当前页，进行page跳转
3. wx.reLaunch 关闭所有页面，进行跳转
4. wx.switchTab 关闭所有非tab页面，跳转到tabbar页面
5. wx.navigateBack 页面返回

## 小程序页面传参

1. url query传递

    ```js
    wx.navigateTo({
      url: '/pages/page1/page1?key=value'
    });

    Page({
      onLoad(options) {
        console.log(options.query.key); // 输出 value
      }
    });
    ```
2. 页面栈传参数

    ```js
    const pages = getCurrentPages();
    const prevPage = pages[pages.length - 2];
    prevPage.setData({
      key: value
    });

    ```

## 小程序父子组件传值

1. 子组件用this.triggerEvent(eventName,value)通知父组件更新
2. 使用vuex

## 小程序分享

使用官方提供的uni.share方法可以分享到其他平台，需要传provider，imageUrl，title等参数

```js
uni.share({
  provider: "qq",
  type: 0,
  title: "这是我分享的商品标题",
  href: "http://192.168.31.95:8080/pages/detail/detail?id=8",
  imageUrl:
    "https://upload-images.jianshu.io/upload_images/5472529-3bd133bd4451e048.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp",
  success: () => {
    uni.showTabBar({
      title: "分享成功",
    });
  },
});

```

## 第三方登录

比如使用qq或者微信账号登录，使用官方提供的uni.login方法即可，另外需要配合uni.getUserInfo()方法，获取到用户在该平台的信息(比如昵称，头像等)，详见官方文档，这里给出简单的代码示例：

```js
uni.login({
  provider: 'qq',
  success: (res) => {
    // 最重要的就是这个openid，需要传递给后端
    const openId = res.authResult.openId;
    uni.getUserInfo({
      provider: mode,
      success: (userInfo) => {
        console.log(userInfo);
      },
    });
    console.log(res);
  },
});

```

## 小程序分包

## 小程序如何调用支付

## 小程序如何获取用户信息

## 小程序发包流程

## 小程序优化

* 避免频繁的操作setData，如果不需要更新视图，直接使用this
* 分页懒加载，避免使用setData传输大数据
* 除开tabBar之外，其他的图片都从服务器加载
* 清理没有用到的代码和资源，减少包的大小
